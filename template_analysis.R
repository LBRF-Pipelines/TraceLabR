##### Template Figure Processing #####
   ### authored by Tony Ingram ###

# This script imports and analyzes large numbers of auto-generated template  
# trajectories. The purpose is to characterize the randomly generated figures 
# (pathlength, complexity, etc.) at the parameters set in TraceLab_params.py.

#### TO DO ####


# rm(list = ls()) # clear work space
#rm(list=setdiff(ls(), c("all_figs"))) # clear all but all_figs
rm(list=setdiff(ls(), c("all_data"))) # clear all but all_data
#rm(list=setdiff(ls(), c("all_figs","all_data"))) # clear all but all_figs & all_data
# graphics.off() # clear figures
# cat("\014") # clear console

# NOTE that there will be everything but .tlt files in the autogenerated zip,
# and .tlf files are large and verbose as they are used for generating figs
# within an experiment. 
# This won't be a problem in importdata.R, as we will be analyzing the 
# experimentally captured data. Keep this in mind for anything you port over.

library(dplyr) # data wrangling
library(ggplot2) # plotting
library(pracma) # for ApEn and SampEn
library(bezier) # for bezier curve analysis

# initialize data frame

# Find all .zip files
path <- "../autofigs"
file.names <- dir(path, recursive = TRUE, full.names = TRUE,pattern="\\.zip$")

# initialize data frame, and name each column up front
all_figs <- data.frame(matrix(ncol = 6, nrow = length(file.names)))
names(all_figs) <- c("figure", "bezfig_len", "sinuosity", "totabscurv", "ApEn", "SampEn")

#i = 4

# analyze all figures
for(i in 1:length(file.names)) {
        name.p <- gsub(".zip",".tlfp",basename(file.names[i]))
        name.s <- gsub(".zip",".tlfs",basename(file.names[i]))
        # name.x <- gsub(".zip",".tlfx",basename(file.names[i])) # tlfx disabled as it did not add any information — see below.
        # read in data 
        tlfp <- read.table(unz(file.names[i], name.p),stringsAsFactors=FALSE, sep=",")
        tlfs <- read.table(unz(file.names[i], name.s),stringsAsFactors=FALSE, sep=",")
        # tlfx <- read.table(unz(file.names[i], name.x),stringsAsFactors=FALSE, sep=",")
        # create data frames
        vertices <- data.frame(matrix(as.numeric(unlist(strsplit(gsub("\\[|\\]|\\(|\\)", "", as.character(tlfp)), ", "))),ncol=2,nrow=length(tlfp)/2, byrow=TRUE)) 
        ctrl_pts <- data.frame(matrix(as.numeric(unlist(strsplit(gsub("\\[|\\]|\\(|\\)", "", as.character(tlfs)), ", "))),ncol=2,nrow=length(tlfs)/2, byrow=TRUE)) 
        # data_five <- data.frame(matrix(as.numeric(unlist(strsplit(gsub("\\[|\\]|\\(|\\)", "", as.character(tlfx)), ", "))),ncol=2,nrow=length(tlfx)/2, byrow=TRUE))
        
        # add file name to data frame:
        all_figs[i,1] <- file.names[i]
        
        # rearrange control points 
        # currently [point, point, ctrl]..., needs to be [point, ctrl, point]
        for(j in 1:nrow(ctrl_pts)){
                if (j %% 3 == 0){
                        ctrl_pts[(j-1):j,] <- ctrl_pts[j:(j-1),]
                }
        } # every 3rd row switched with previous row
        
        # rearrange ctrl_pts to get rid of repeated points
        # this is needed for the bezier package
        ctrl_pts_rm <- ctrl_pts[c(1:3,5:6,8:9,11:12,14:15),]
        
        # ctrl_pts_rm <- ctrl_pts[1,]
        # for(j in 2:nrow(ctrl_pts)){
        #         if (!(ctrl_pts[j,1] == ctrl_pts[j-1,1] & ctrl_pts[j,2] == ctrl_pts[j-1,2])){
        #                 ctrl_pts_rm <- rbind(ctrl_pts_rm, ctrl_pts[j,])
        #         }
        # } # this didn't work as there are occaisons where the control point is == to an end point...
        
        # test to see if this worked:
        # bez_test <- bezier::bezier(t, ctrl_pts_rm, deg=2)
        # plot(bez_test[,1],bez_test[,2], xlim=c(0,1920), ylim=c(1080,0))
        
        ##### data_five analysis #####
        ## no longer implimented as the five sec data didn't add anything useful
        
        # plot(data_five$X1,data_five$X2, xlim=c(0,1920), ylim=c(1080,0))
        
        # how many data points in five seconds?
        # data_five_n <- nrow(data_five)
        # all_figs[i,2] <- data_five_n 
        
        # # are data_five points equally spaced?
        # data_five_d <- matrix()
        # for (k in 1:(nrow(data_five)-1)) {
        #         d_length <- sqrt((data_five[k+1,1]-data_five[k,1])^2 + (data_five[k+1,2]-data_five[k,2])^2)
        #         data_five_d[k] <- d_length
        # }
        # # print(data_five_d)
        # plot(data_five_d)
        # mean(data_five_d)
        # sd(data_five_d)
        
        # NOPE :/ 
        
        ##### interpolate data_five to make it equally spaced #####
        
        # spl.time <- seq(0, 1, length=nrow(data_five))
        # xnew <- splinefun(spl.time, data_five$X1)
        # ynew <- splinefun(spl.time, data_five$X2)
        # spl.time2 <- seq(min(spl.time), max(spl.time), length.out = 500)
        # five_fig <- matrix(cbind(xnew(spl.time2), ynew(spl.time2)), ncol=2)
        # #plot(five_fig[,1], five_fig[,2], xlim=c(0,1920), ylim=c(1080,0))
        # 
        # # are five_fig points equally spaced after the spline interpolation?
        # five_fig_d <- matrix()
        # for (k in 1:(nrow(five_fig)-1)) {
        #         d_length <- sqrt((five_fig[k+1,1]-five_fig[k,1])^2 + (five_fig[k+1,2]-five_fig[k,2])^2)
        #         five_fig_d[k] <- d_length
        # }
        # print(five_fig_d) # NO... WTF
        
        
        ##### Bezier Curve Analysis #####
        
        # Bezier Curve Functions:
        bezier0 <- function(t, p){
                b0x = (((1-t)^2)*p[1,1]) + (2*(1-t)*t*p[2,1]) + ((t^2)*p[3,1])
                b0y = (((1-t)^2)*p[1,2]) + (2*(1-t)*t*p[2,2]) + ((t^2)*p[3,2])
                b0 <- cbind(b0x,b0y)
                return(b0)
        } # create quadratic bez curve
        bezier1 <- function(t, p){
                b1x = (2 * (1-t) * (p[2,1]-p[1,1])) + (2 * t * (p[3,1] - p[2,1]))
                b1y = (2 * (1-t) * (p[2,2]-p[1,2])) + (2 * t * (p[3,2] - p[2,2]))
                b1 <- cbind(b1x,b1y)
                return(b1)
        } # first deriv of quad bez
        bezier2 <- function(t, p){
                b2x = (2 * (p[3,1] - (2 * p[2,1]) + p[1,1]))
                b2y = (2 * (p[3,2] - (2 * p[2,2]) + p[1,2]))
                b2 <- cbind(b2x,b2y)
                return(b2)
        } # second deriv of quad bez
        bcurv = function(t, p){
                b1x = (2 * (1-t) * (p[2,1]-p[1,1])) + (2 * t * (p[3,1] - p[2,1])) #first derivative of x
                b1y = (2 * (1-t) * (p[2,2]-p[1,2])) + (2 * t * (p[3,2] - p[2,2])) #first derivative of y
                b2x = (2 * (p[3,1] - (2 * p[2,1]) + p[1,1])) #second derivative of x
                b2y = (2 * (p[3,2] - (2 * p[2,2]) + p[1,2])) #second derivative of y
                bez_curvature <- ((b1x * b2y) - (b1y * b2x))/(((b1x^2) + (b1y^2))^(3/2)) #signed curvature
                return(bez_curvature)
        } # curvature at t points
        
        ### reproduce figure using control points: ###
        
        # *NOTE* that these methods do not produce equally spaced points, 
        # but see below — don't need.
        
        # # recreate figure using my own functions:
        # n_segs <- 5
        # t <- seq(0, 1, length=300/n_segs)
        # bez_fig <- matrix(rbind(
        #         bezier0(t, ctrl_pts[1:3,])
        #         , bezier0(t, ctrl_pts[4:6,])
        #         , bezier0(t, ctrl_pts[7:9,])
        #         , bezier0(t, ctrl_pts[10:12,])
        #         , bezier0(t, ctrl_pts[13:15,])
        #         ), ncol=2)
        
        # another method, using bezier package:
        t <- seq(0, 5, length=300) # t for five curves
        bez_fig <- bezier(t, ctrl_pts_rm, deg=2)
        # plot(bez_fig[,1], bez_fig[,2], xlim=c(0,1920), ylim=c(1080,0))
        
        # make equally spaced figure: (don't need for now)
         
        # bez_eqsp <- pointsOnBezier(
        #         ctrl_pts_rm
        #         , n = 300
        #         , method = 'evenly_spaced'
        #         , deg = 2
        #         , print.progress = TRUE
        #         , sub.relative.min.slope = 1e-2
        # )
        # plot(bez_eqsp$points[,1],bez_eqsp$points[,2], xlim=c(0,1920), ylim=c(1080,0))
        # 
        # # are bez_eqsp$points equally spaced after for real?
        # bez_eqsp_d <- matrix()
        # for (k in 1:(nrow(bez_eqsp$points)-1)) {
        #         d_length <- sqrt((bez_eqsp$points[k+1,1]-bez_eqsp$points[k,1])^2 + (bez_eqsp$points[k+1,2]-bez_eqsp$points[k,2])^2)
        #         bez_eqsp_d[k] <- d_length
        # }
        # # plot(bez_eqsp_d)
        # mean(bez_eqsp_d)
        # sd(bez_eqsp_d) # YAAAAAS IT WORKS... the generation is crazy slow though...

        
        ##### arclength #####
        
        bezfig_len <- bezierArcLength(
                ctrl_pts_rm
                , deg = 2
        )
        # print(bezfig_len$arc.length)
        all_figs[i,2] <- bezfig_len$arc.length
        
        # # adding up distances for not equidistant points:
        # bez_fig_d <- matrix()
        # for (k in 1:(nrow(bez_fig)-1)) {
        #         d_length <- sqrt((bez_fig[k+1,1]-bez_fig[k,1])^2 + (bez_fig[k+1,2]-bez_fig[k,2])^2)
        #         bez_fig_d[k] <- d_length
        # }
        # sum(bez_fig_d)
        # 
        # # adding up distances for equidistant points:
        # bez_eqsp_d <- matrix()
        # for (k in 1:(nrow(bez_eqsp$points)-1)) {
        #         d_length <- sqrt((bez_eqsp$points[k+1,1]-bez_eqsp$points[k,1])^2 + (bez_eqsp$points[k+1,2]-bez_eqsp$points[k,2])^2)
        #         bez_eqsp_d[k] <- d_length
        # }
        # sum(bez_eqsp_d)
        # 
        # # BARELY DIFFERENT... yaaaaas!!!! just use function then... 
        
        
        ##### sinuosity #####
        
        segs <- matrix()
        for (j in 1:NROW(vertices)) {
                seg_len <- sqrt((vertices[j+1,1]-vertices[j,1])^2 + (vertices[j+1,2]-vertices[j,2])^2)
                segs <- rbind(segs, seg_len)
        }
        perimeter <- sum(segs, na.rm = TRUE)
        pathlength <- bezfig_len$arc.length
        sinuosity <- pathlength/perimeter
        all_figs[i,3] <- sinuosity
        
        ##### curvature #####
        
        # # using my own function, so need to specify t as such:
        # n_segs <- 5
        # t <- seq(0, 1, length=300/n_segs)
        # curvature <- c(bcurv(t, ctrl_pts[1:3,])
        #              , bcurv(t, ctrl_pts[4:6,])
        #              , bcurv(t, ctrl_pts[7:9,])
        #              , bcurv(t, ctrl_pts[10:12,])
        #              , bcurv(t, ctrl_pts[13:15,])
        # )
        # plot(curvature) # looks very odd
        # # obviously not a good way to look at this... 
        # 
        # # calculate curvature with equally spaced points:
        # s <- seq(from = 1, to = 100, length.out = nrow(bez_eqsp$points)) # ends at 99.888889
        # s2 <- s #seq(min(s), max(s), length.out = 10000) # ends at 99.888889
        # xt.spl <- splinefun(x = s, y = bez_eqsp$points[,1]) 
        # yt.spl <- splinefun(x = s, y = bez_eqsp$points[,2])
        # curvature2 = (
        #         (xt.spl(s2, deriv=1) * yt.spl(s2, deriv=2)) - (yt.spl(s2, deriv=1) * xt.spl(s2, deriv=2)))/
        #         ((xt.spl(s2, deriv=1)^2 + yt.spl(s2, deriv=1)^2)^(3/2)) #signed curvature
        # plot(s2, curvature2, ylim= c(-0.015,0.06))
        # 
        # approx_entropy(curvature)
        # approx_entropy(curvature2) #these two barely different... 
        # 
        # sample_entropy(curvature)
        # sample_entropy(curvature2) #these two pretty different...
        # 
        # # CONCLUSION: using equally spaced points doesn't seem to make a difference
        # # also, both ApEn and SampEn calculations are very similar to to what we're
        # # getting with turning angle below. As turning angle accounts for the actual
        # # segment change, I prefer that for the regularity score.
        
        # calculate total absolute curvature of each segment and sum:
        n_segs <- 5
        t <- seq(0, 1, length=300/n_segs)
        
        totabscurv <- (integrate(
                        splinefun(
                                x = t, y = abs(
                                        bcurv(t, ctrl_pts[1:3,])
                                )
                        )
                , min(t), max(t))
                )$value + (integrate(
                        splinefun(
                                x = t, y = abs(
                                        bcurv(t, ctrl_pts[4:6,])
                                )
                        )
                        , min(t), max(t))
                )$value +(integrate(
                        splinefun(
                                x = t, y = abs(
                                        bcurv(t, ctrl_pts[7:9,])
                                )
                        )
                        , min(t), max(t))
                )$value +(integrate(
                        splinefun(
                                x = t, y = abs(
                                        bcurv(t, ctrl_pts[10:12,])
                                )
                        )
                        , min(t), max(t))
                )$value +(integrate(
                        splinefun(
                                x = t, y = abs(
                                        bcurv(t, ctrl_pts[13:15,])
                                )
                        )
                        , min(t), max(t))
                )$value
        all_figs[i,4] <- totabscurv
        
        
        ##### approximate entropy / sample entropy #####
        
        # using bez curve NOT equally distant points:
        
        # create "turning angle" sequence, reducing 2D (x,y) to 1D (relative angle):
        bez_fig_theta <- rep(0, length(bez_fig[,1])-2) # note you always lose two points
        for (a in 1:length(bez_fig_theta)){
                V1 = c(bez_fig[a+1,1],bez_fig[a+1,2]) - c(bez_fig[a,1],bez_fig[a,2])
                V2 = c(bez_fig[a+2,1],bez_fig[a+2,2]) - c(bez_fig[a+1,1],bez_fig[a+1,2])
                bez_fig_theta[a] = atan2(V2[2],V2[1]) - atan2(V1[2],V1[1])
                if (abs(bez_fig_theta[a]) > pi){
                        bez_fig_theta[a] = bez_fig_theta[a] - ((2*pi)*sign(bez_fig_theta[a]))
                }
        }
        all_figs[i,5] <- approx_entropy(bez_fig_theta) # note, increasing length of sequence decreases both significantly... 
        all_figs[i,6] <- sample_entropy(bez_fig_theta) # sample entropy isn't supposed to be like that... what gives? 
        
        # using bez curve WITH equally distant points:
        
        # # create "turning angle" sequence, reducing 2D (x,y) to 1D (relative angle):
        # bez_eqsp_theta <- rep(0, length(bez_eqsp$points[,1])-2) # note you always lose two points
        # for (a in 1:length(bez_eqsp_theta)){
        #         V1 = c(bez_eqsp$points[a+1,1],bez_eqsp$points[a+1,2]) - c(bez_eqsp$points[a,1],bez_eqsp$points[a,2])
        #         V2 = c(bez_eqsp$points[a+2,1],bez_eqsp$points[a+2,2]) - c(bez_eqsp$points[a+1,1],bez_eqsp$points[a+1,2])
        #         bez_eqsp_theta[a] = atan2(V2[2],V2[1]) - atan2(V1[2],V1[1])
        #         if (abs(bez_eqsp_theta[a]) > pi){
        #                 bez_eqsp_theta[a] = bez_eqsp_theta[a] - ((2*pi)*sign(bez_eqsp_theta[a]))
        #         }
        # }
        # approx_entropy(bez_eqsp_theta)
        # sample_entropy(bez_eqsp_theta)
        
        # very slight difference in entropy scores when normalizing distances... 
        # might not be necessary for this analysis... ? would help speed big time... 
        
        
        
}



