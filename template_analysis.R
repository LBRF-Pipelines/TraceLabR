##### Template Figure Analysis #####
##### authored by Tony Ingram #####

# This script analyzes large numbers of auto-generated template trajectory 
# figures. The purpose is to characterize the randomly generated figures 
# (pathlength, complexity, etc.) at the parameters set in TraceLab_params.py.

# rm(list = ls()) # clear work space
rm(list=setdiff(ls(), c("all_figs","all_data"))) # clear all but all_figs
# graphics.off() # clear figures
# cat("\014") # clear console

# NOTE that there will be everything but .tlt files in the autogenerated zip,
# and .tlf files are large and verbose as they are used for generating figs
# within an experiment. 
# This won't be a problem in importdata.R, as we will be analyzing the 
# experimentally captured data. Keep this in mind for anything you port over.

library(dplyr) # data wrangling
library(ggplot2) # plotting
library(pracma) # for ApEn and SampEn
library(bezier) # for bezier curve analysis

# Find all .zip files
path <- "../autofigs"
file.names <- dir(path, recursive = TRUE, full.names = TRUE,pattern="\\.zip$")

# initialize data frame, and name each column up front
all_figs <- data.frame(matrix(ncol = 2, nrow = length(file.names)))
names(all_figs) <- c("data_five_n","blah")

#i = 1

# analyze all figures
for(i in 1:length(file.names)) {
        name.p <- gsub(".zip",".tlfp",basename(file.names[i]))
        name.s <- gsub(".zip",".tlfs",basename(file.names[i]))
        name.x <- gsub(".zip",".tlfx",basename(file.names[i]))
        # read in data 
        tlfp <- read.table(unz(file.names[i], name.p),stringsAsFactors=FALSE, sep=",")
        tlfs <- read.table(unz(file.names[i], name.s),stringsAsFactors=FALSE, sep=",")
        tlfx <- read.table(unz(file.names[i], name.x),stringsAsFactors=FALSE, sep=",")
        # create data frames
        vertices <- data.frame(matrix(as.numeric(unlist(strsplit(gsub("\\[|\\]|\\(|\\)", "", as.character(tlfp)), ", "))),ncol=2,nrow=length(tlfp)/2, byrow=TRUE)) 
        ctrl_pts <- data.frame(matrix(as.numeric(unlist(strsplit(gsub("\\[|\\]|\\(|\\)", "", as.character(tlfs)), ", "))),ncol=2,nrow=length(tlfs)/2, byrow=TRUE)) 
        data_five <- data.frame(matrix(as.numeric(unlist(strsplit(gsub("\\[|\\]|\\(|\\)", "", as.character(tlfx)), ", "))),ncol=2,nrow=length(tlfx)/2, byrow=TRUE))
        
        # rearrange control points 
        # currently [point, point, ctrl]..., needs to be [point, ctrl, point]
        for(j in 1:nrow(ctrl_pts)){
                if (j %% 3 == 0){
                        ctrl_pts[(j-1):j,] <- ctrl_pts[j:(j-1),]
                }
        } # every 3rd row switched with previous row
        
        ##### data_five analysis #####
        
        # how many data points in five seconds?
        data_five_n <- nrow(data_five)
        all_figs[i,1] <- data_five_n 
        
        # are data_five points equally spaced?
        data_five_d <- matrix()
        for (k in 1:(nrow(data_five)-1)) {
                d_length <- sqrt((data_five[k+1,1]-data_five[k,1])^2 + (data_five[k+1,2]-data_five[k,2])^2)
                data_five_d[k] <- d_length
        }
        # print(data_five_d)
        # plot(data_five_d)
        # plot(data_five$X1,-data_five$X2)
        
        # NOPE :/ 
        
        ##### interpolate data_five to make it equally spaced #####
        
        spl.time <- seq(0, 1, length=nrow(data_five))
        xnew <- splinefun(spl.time, data_five$X1)
        ynew <- splinefun(spl.time, data_five$X2)
        spl.time2 <- seq(min(spl.time), max(spl.time), length.out = 500)
        five_fig <- matrix(cbind(xnew(spl.time2), ynew(spl.time2)), ncol=2)
        #plot(five_fig[,1], five_fig[,2], xlim=c(0,1920), ylim=c(1080,0))
        
        # are five_fig points equally spaced after the spline interpolation?
        five_fig_d <- matrix()
        for (k in 1:(nrow(five_fig)-1)) {
                d_length <- sqrt((five_fig[k+1,1]-five_fig[k,1])^2 + (five_fig[k+1,2]-five_fig[k,2])^2)
                five_fig_d[k] <- d_length
        }
        #print(five_fig_d) # NO... WTF
        
        
        
        ##### Bezier Curve Analysis #####
        
        # Bezier Curve Functions:
        bezier0 <- function(t, p){
                b0x = (((1-t)^2)*p[1,1]) + (2*(1-t)*t*p[2,1]) + ((t^2)*p[3,1])
                b0y = (((1-t)^2)*p[1,2]) + (2*(1-t)*t*p[2,2]) + ((t^2)*p[3,2])
                b0 <- cbind(b0x,b0y)
                return(b0)
        } # create quadratic bez curve
        bezier1 <- function(t, p){
                b1x = (2 * (1-t) * (p[2,1]-p[1,1])) + (2 * t * (p[3,1] - p[2,1]))
                b1y = (2 * (1-t) * (p[2,2]-p[1,2])) + (2 * t * (p[3,2] - p[2,2]))
                b1 <- cbind(b1x,b1y)
                return(b1)
        } # first deriv of quad bez
        bezier2 <- function(t, p){
                b2x = (2 * (p[3,1] - (2 * p[2,1]) + p[1,1]))
                b2y = (2 * (p[3,2] - (2 * p[2,2]) + p[1,2]))
                b2 <- cbind(b2x,b2y)
                return(b2)
        } # second deriv of quad bez
        bcurv = function(t, p){
                b1x = (2 * (1-t) * (p[2,1]-p[1,1])) + (2 * t * (p[3,1] - p[2,1])) #first derivative of x
                b1y = (2 * (1-t) * (p[2,2]-p[1,2])) + (2 * t * (p[3,2] - p[2,2])) #first derivative of y
                b2x = (2 * (p[3,1] - (2 * p[2,1]) + p[1,1])) #second derivative of x
                b2y = (2 * (p[3,2] - (2 * p[2,2]) + p[1,2])) #second derivative of y
                bez_curv <- ((b1x * b2y) - (b1y * b2x))/(((b1x^2) + (b1y^2))^(3/2)) #signed curvature
                return(bez_curv)
        } # curvature at t points
        
        # reproduce figure using control points:
        
        # *NOTE* that this doesn't produce equally spaced points.
        # use splines for this? even necessary for integrating later?
        # what about arclength? 
        
        t <- seq(0, 1, length=100)
        # make this a function or loop of some sort... geez
        bez_points1 <- bezier0(t, ctrl_pts[1:3,])
        bez_points2 <- bezier0(t, ctrl_pts[4:6,])
        bez_points3 <- bezier0(t, ctrl_pts[7:9,])
        bez_points4 <- bezier0(t, ctrl_pts[10:12,])
        bez_points5 <- bezier0(t, ctrl_pts[13:15,])
        bez_fig <- matrix(rbind(bez_points1,bez_points2,bez_points3,bez_points4,bez_points5), ncol=2)
        
        # plot(bez_fig[,1], bez_fig[,2], xlim=c(0,1920), ylim=c(1080,0))
        # compare to real figure:
        # plot(data_five$X1, data_five$X2, xlim=c(0,1920), ylim=c(1080,0))
        # WTF IS HAPPENING?! for now use bez points... 
        
        # what if I screw with control points?
        # make x of control points negative
        
        # make equally spaced figure:
        t <- seq(0, 5, length=200) # t for five curves
        # rearrange ctrl_pts to get rid of repeated points
        ctrl_pts_rm <- ctrl_pts[1,]
        for(j in 2:nrow(ctrl_pts)){
                if (ctrl_pts[j,] != ctrl_pts[j-1,]){
                        ctrl_pts_rm <- rbind(ctrl_pts_rm, ctrl_pts[j,])
                }
        }
        #bez_test <- bezier(t, ctrl_pts_rm, deg=2)
        #plot(bez_test[,1],bez_test[,2], xlim=c(0,1920), ylim=c(1080,0))
        
        bez_eqsp <- pointsOnBezier(ctrl_pts_rm, n = 200
                                   , method = 'evenly_spaced'
                                   , deg = 2
                                   , print.progress = TRUE)
        #plot(bez_eqsp$points[,1],bez_eqsp$points[,2], xlim=c(0,1920), ylim=c(1080,0))
        
        # # are bez_eqsp$points equally spaced after for real?
        # bez_eqsp_d <- matrix()
        # for (k in 1:(nrow(bez_eqsp$points)-1)) {
        #         d_length <- sqrt((bez_eqsp$points[k+1,1]-bez_eqsp$points[k,1])^2 + (bez_eqsp$points[k+1,2]-bez_eqsp$points[k,2])^2)
        #         bez_eqsp_d[k] <- d_length
        # }
        # plot(bez_eqsp_d)
        # mean(bez_eqsp_d)
        # sd(bez_eqsp_d) # YAAAAAS IT WORKS... the generation is crazy slow though... 

        
        ##### approximate entropy / sample entropy #####
        
        # using bez curve NOT equally distant points:
        
        # create "turning angle" sequence, reducing 2D (x,y) to 1D (relative angle):
        bez_test_theta <- rep(0, length(bez_test[,1])-2) # note you always lose two points
        for (a in 1:length(bez_test_theta)){
                V1 = c(bez_test[a+1,1],bez_test[a+1,2]) - c(bez_test[a,1],bez_test[a,2])
                V2 = c(bez_test[a+2,1],bez_test[a+2,2]) - c(bez_test[a+1,1],bez_test[a+1,2])
                bez_test_theta[a] = atan2(V2[2],V2[1]) - atan2(V1[2],V1[1])
                if (abs(bez_test_theta[a]) > pi){
                        bez_test_theta[a] = bez_test_theta[a] - ((2*pi)*sign(bez_test_theta[a]))
                }
        }
        approx_entropy(bez_test_theta)
        sample_entropy(bez_test_theta)
        
        # using bez curve NOT equally distant points:
        
        # create "turning angle" sequence, reducing 2D (x,y) to 1D (relative angle):
        bez_eqsp_theta <- rep(0, length(bez_eqsp$points[,1])-2) # note you always lose two points
        for (a in 1:length(bez_eqsp_theta)){
                V1 = c(bez_eqsp$points[a+1,1],bez_eqsp$points[a+1,2]) - c(bez_eqsp$points[a,1],bez_eqsp$points[a,2])
                V2 = c(bez_eqsp$points[a+2,1],bez_eqsp$points[a+2,2]) - c(bez_eqsp$points[a+1,1],bez_eqsp$points[a+1,2])
                bez_eqsp_theta[a] = atan2(V2[2],V2[1]) - atan2(V1[2],V1[1])
                if (abs(bez_eqsp_theta[a]) > pi){
                        bez_eqsp_theta[a] = bez_eqsp_theta[a] - ((2*pi)*sign(bez_eqsp_theta[a]))
                }
        }
        approx_entropy(bez_eqsp_theta)
        sample_entropy(bez_eqsp_theta)
        
        # very slight difference in entropy scores when normalizing distances... 
        # might not be necessary for this analysis... ?
        
        
}



