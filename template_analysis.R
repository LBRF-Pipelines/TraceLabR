##### Template Figure Analysis #####
##### authored by Tony Ingram #####

# This script analyzes large numbers of auto-generated template trajectory 
# figures. The purpose is to characterize the randomly generated figures 
# (pathlength, complexity, etc.) at the parameters set in TraceLab_params.py.

rm(list = ls()) # clear work space
# rm(list=setdiff(ls(), "all_data")) # clear all but all_data (change name for this)
# graphics.off() # clear figures
# cat("\014") # clear console

# NOTE that there will be everything but .tlt files in the autogenerated zip,
# and .tlf files are large and verbose as they are used for generating figs
# within an experiment. 
# This won't be a problem in importdata.R, as we will be analyzing the 
# experimentally captured data. Keep this in mind for anything you port over.

library(dplyr) # data wrangling
library(ggplot2) # plotting
library(pracma) # for ApEn and SampEn
library(bezier) # for bezier curve analysis

# Find all .zip files
path <- "../autofigs"
file.names <- dir(path, recursive = TRUE, full.names = TRUE,pattern="\\.zip$")

# initialize data frame, and name each column up front
all_figs <- data.frame(matrix(ncol = 2, nrow = length(file.names)))
names(all_figs) <- c("data_five_n","blah")

# analyze all figures
for(i in 1:length(file.names)) {
        name.p <- gsub(".zip","_.tlfp",basename(file.names[i]))
        name.s <- gsub(".zip","_.tlfs",basename(file.names[i]))
        name.x <- gsub(".zip","_.tlfx",basename(file.names[i]))
        # read in data 
        tlfp <- read.table(unz(file.names[i], name.p),stringsAsFactors=FALSE, sep=",")
        tlfs <- read.table(unz(file.names[i], name.s),stringsAsFactors=FALSE, sep=",")
        tlfx <- read.table(unz(file.names[i], name.x),stringsAsFactors=FALSE, sep=",")
        # create data frames
        vertices <- data.frame(matrix(as.numeric(unlist(strsplit(gsub("\\[|\\]|\\(|\\)", "", as.character(tlfp)), ", "))),ncol=2,nrow=length(tlfp)/2, byrow=TRUE)) 
        ctrl_pts <- data.frame(matrix(as.numeric(unlist(strsplit(gsub("\\[|\\]|\\(|\\)", "", as.character(tlfs)), ", "))),ncol=2,nrow=length(tlfs)/2, byrow=TRUE)) 
        data_five <- data.frame(matrix(as.numeric(unlist(strsplit(gsub("\\[|\\]|\\(|\\)", "", as.character(tlfx)), ", "))),ncol=2,nrow=length(tlfx)/2, byrow=TRUE))
        
        # rearrange control points 
        # currently [point, point, ctrl]..., needs to be [point, ctrl, point]
        for(j in 1:nrow(ctrl_pts)){
                if (j %% 3 == 0){
                        ctrl_pts[(j-1):j,] <- ctrl_pts[j:(j-1),]
                }
        } # every 3rd row switched with previous row
        
        # how many data points in five seconds?
        data_five_n <- nrow(data_five)
        all_figs[i,1] <- data_five_n 
        
        # Bezier Curve Functions:
        bezier0 <- function(t, p){
                b0x = (((1-t)^2)*p[1,1]) + (2*(1-t)*t*p[2,1]) + ((t^2)*p[3,1])
                b0y = (((1-t)^2)*p[1,2]) + (2*(1-t)*t*p[2,2]) + ((t^2)*p[3,2])
                b0 <- cbind(b0x,b0y)
                return(b0)
        } # create quadratic bez curve
        bezier1 <- function(t, p){
                b1x = (2 * (1-t) * (p[2,1]-p[1,1])) + (2 * t * (p[3,1] - p[2,1]))
                b1y = (2 * (1-t) * (p[2,2]-p[1,2])) + (2 * t * (p[3,2] - p[2,2]))
                b1 <- cbind(b1x,b1y)
                return(b1)
        } # first deriv of quad bez
        bezier2 <- function(t, p){
                b2x = (2 * (p[3,1] - (2 * p[2,1]) + p[1,1]))
                b2y = (2 * (p[3,2] - (2 * p[2,2]) + p[1,2]))
                b2 <- cbind(b2x,b2y)
                return(b2)
        } # second deriv of quad bez
        bcurv = function(t, p){
                b1x = (2 * (1-t) * (p[2,1]-p[1,1])) + (2 * t * (p[3,1] - p[2,1])) #first derivative of x
                b1y = (2 * (1-t) * (p[2,2]-p[1,2])) + (2 * t * (p[3,2] - p[2,2])) #first derivative of y
                b2x = (2 * (p[3,1] - (2 * p[2,1]) + p[1,1])) #second derivative of x
                b2y = (2 * (p[3,2] - (2 * p[2,2]) + p[1,2])) #second derivative of y
                bez_curv <- ((b1x * b2y) - (b1y * b2x))/(((b1x^2) + (b1y^2))^(3/2)) #signed curvature
                return(bez_curv)
        } # curvature at t points
        
        
        
}




